"use strict";

const path = require("path");
const fs = require("fs");
const util = require("util");

const readdir = util.promisify(fs.readdir);

// sort function
const sortByDirentThenExtensionThenName = (a, b) => {
  if (a.direntType > b.direntType) {
    return 1;
  }
  if (a.direntType < b.direntType) {
    return -1;
  }

  if (a.extension.toLowerCase() > b.extension.toLowerCase()) {
    return 1;
  }
  if (a.extension.toLowerCase() < b.extension.toLowerCase()) {
    return -1;
  }

  if (a.name.toLowerCase() > b.name.toLowerCase()) {
    return 1;
  }
  if (a.name.toLowerCase() < b.name.toLowerCase()) {
    return -1;
  }

  return 0;
};

const countMatchesIgnoringUndefined = aString => {
  const matchObject = aString.match(/\./g);
  if (matchObject) {
    return matchObject.length;
  }
  return 0;
};

/**
 * Shallowly scan a directory.
 * @param {String} dir - a directory to scan.
 * @param {Object} options
 * @param {String=} options.sort - either "name" or "kind".
 * @param {Boolean=} options.ignoreDotFiles
 * @param {Boolean=} options.ignoreMiscFiles - ".DS_Store", ".dropbox.cache" etc.
 * @returns {string[]} array of paths.
 */
module.exports = async (dir, options) => {
  const miscFiles = [
    ".DS_Store",
    ".dropbox",
    ".localized",
    "Icon\r",
    ".dropbox.cache",
    ".ws.agile.1Password.settings"
  ];
  let withFileTypes;
  let sortBy;
  let ignoreDotFiles;
  let ignoreMiscFiles = true;

  if (options && options.sort === "kind") {
    withFileTypes = true;
  }

  let globResults = await readdir(dir, {
    withFileTypes
  });

  if (options) {
    if (options.sort === "name") sortBy = "name";
    if (options.sort === "kind") sortBy = "kind";
    if (options.ignoreDotFiles === true) ignoreDotFiles = true;
    if (options.ignoreMiscFiles === false) ignoreMiscFiles = false;
  }

  if (ignoreMiscFiles) {
    globResults = globResults.filter(fileNameOrDirEnt => {
      return !miscFiles.includes(fileNameOrDirEnt.name || fileNameOrDirEnt);
    });
  }

  if (ignoreDotFiles) {
    globResults = globResults.filter(fileNameOrDirEnt => {
      return !/^\..+/.test(fileNameOrDirEnt.name || fileNameOrDirEnt);
    });
  }

  if (sortBy === "kind") {
    globResults = globResults
      .map(dirent => {
        let direntType;
        let extension;
        const { name } = dirent;
        // folders with a single . in their name are treated as apps (= files)
        if (
          // eslint-disable-next-line
          (dirent.isDirectory() &&
            countMatchesIgnoringUndefined(name) === 1 &&
            !name.startsWith(".")) ||
          dirent.isFile()
        ) {
          extension = path.extname(name);
          direntType = 2;
        } else if (dirent.isDirectory()) {
          extension = "";
          direntType = 1;
        } else if (dirent.isSymbolicLink()) {
          extension = "";
          direntType = 0;
        }
        const pathObject = {
          name,
          direntType,
          extension
        };
        return pathObject;
      })
      .sort(sortByDirentThenExtensionThenName)
      .map(dirent => {
        return dirent.name;
      });
  } else if (sortBy === "name") {
    globResults.sort((a, b) => a.localeCompare(b));
  }
  return globResults.map(fileName => {
    return path.join(dir, fileName);
  });
};
