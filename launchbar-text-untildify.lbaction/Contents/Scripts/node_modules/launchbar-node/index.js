"use strict";

const runApplescript = require("run-applescript");
const clipboardy = require("clipboardy");
const escapeString = require("escape-string-applescript");
const CacheConf = require("cache-conf");
const got = require("got");
const Conf = require("conf");

const LaunchBar = module.exports;

/**
 * the absolute path the LaunchBar.app package.
 */
LaunchBar.path = process.env.LB_LAUNCHBAR_PATH;

/**
 * @property {string} LaunchBar.options.commandKey True is this key was held down when the action was invoked.
 * @property {string} LaunchBar.options.alternateKey True is this key was held down when the action was invoked.
 * @property {string} LaunchBar.options.shiftKey True is this key was held down when the action was invoked.
 * @property {string} LaunchBar.options.controlKey True is this key was held down when the action was invoked.
 * @property {string} LaunchBar.options.spaceKey True is this key was held down when the action was invoked.
 */
LaunchBar.options = {
  commandKey: process.env.LB_OPTION_COMMAND_KEY === "1",
  alternateKey: process.env.LB_OPTION_ALTERNATE_KEY === "1",
  shiftKey: process.env.LB_OPTION_SHIFT_KEY === "1",
  controlKey: process.env.LB_OPTION_CONTROL_KEY === "1",
  spaceKey: process.env.LB_OPTION_SPACE_KEY === "1"
};

// TODO:
// environment variables considered for inclusion:
// LB_DEBUG_LOG_ENABLED
// LB_SCRIPT_TYPE
// LB_OPTION_RUN_IN_BACKGROUND
// LB_OPTION_LIVE_FEEDBACK
/**
 * @property {string} LaunchBar.action.path - the absolute path the current action's .lbaction package
 * @property {string} LaunchBar.action.supportPath - the absolute path the current action's support folder (~/Library/Application Support/LaunchBar/Action Support/)
 * @property {string} LaunchBar.action.cachePath - the absolute path the current action's cache folder (in ~/Library/Caches/at.obdev.LaunchBar/Actions/)
 */
LaunchBar.action = {
  path: process.env.LB_ACTION_PATH,
  supportPath: process.env.LB_SUPPORT_PATH,
  cachePath: process.env.LB_CACHE_PATH
};

// TODO:
// an action.item object?
// caching for live feedback actions
// query
// chosenItem
// allItems
// title
// subtitle
// url
// path
// icon
// iconFont
// iconIsTemplate
// quickLookURL
// action

// eschew this?
// actionArgument

// actionReturnsItems
// actionRunsInBackground
// actionBundleIdentifier
// children

/**
 * hides LaunchBar.
 */
LaunchBar.hide = async () => {
  try {
    await runApplescript('tell application "LaunchBar" to hide');
  } catch (error) {
    throw error;
  }
};

/**
 * keeps LaunchBar active.
 */
LaunchBar.remainActive = async () => {
  try {
    return await runApplescript(
      'tell application "LaunchBar" to remain active'
    );
  } catch (error) {
    throw error;
  }
};

/**
 * checks whether LB has keyboard focus.
 * @returns {boolean} True if LB has keyboard focus, otherwise false.
 */
LaunchBar.hasKeyboardFocus = async () => {
  try {
    const result = await runApplescript(
      'tell application "LaunchBar" to return has keyboard focus'
    );
    return result === "true";
  } catch (error) {
    throw error;
  }
};

/**
 * Asynchronously sets the clipboard's contents.
 * @param {string} text the text to copy to the clipboard.
 */
LaunchBar.setClipboardString = async text => {
  try {
    return await clipboardy.write(text);
  } catch (error) {
    throw error;
  }
};

/**
 * Asynchronously clears the clipboard's contents.
 */
LaunchBar.clearClipboard = async () => {
  try {
    return await clipboardy.write("");
  } catch (error) {
    throw error;
  }
};

/**
 * Asynchronously pastes passed text into the frontmost application.
 * @param {string} text the text to paste.
 */
LaunchBar.paste = async text => {
  try {
    return await runApplescript(
      `tell application "LaunchBar" to paste in frontmost application "${escapeString(
        text
      )}"`
    );
  } catch (error) {
    throw error;
  }
};

/**
 * Perform a macOS service.
 * Available services could be seen in the index.
 * @param {string} service the service to perform.
 * @param {string=} argv service's arguments.
 */
LaunchBar.performService = async (service, argv) => {
  const escapedArgv = escapeString(argv);
  await runApplescript(
    `tell application "LaunchBar" to perform service "${service}" with string "${escapedArgv}"`
  );
};

/**
 * Displays a message in Notification Center.
 * @param {string=} text - the message's body.
 * @param {string=} title - the message's title. Defaults to "LaunchBar".
 * @param {string=} subtitle - the message's subtitle.
 * @param {string=} callbackUrl - URL opened if notificiation is clicked.
 * @param {integer=} afterDelay - time in seconds after which the notification is shown.
 */
LaunchBar.displayNotification = async (
  text,
  title,
  subtitle,
  callbackUrl,
  afterDelay
) => {
  text = text ? text : "";
  title = title ? title : "LaunchBar";
  subtitle = subtitle ? subtitle : "";
  callbackUrl = callbackUrl ? callbackUrl : "";
  afterDelay = afterDelay ? afterDelay : 0;
  await runApplescript(`tell application "LaunchBar" to display in notification center "${text}" ¬
		with title "${title}" ¬
		subtitle "${subtitle}" ¬
		callback URL "${callbackUrl}" ¬
		after delay "${afterDelay.toString()}"`);
};

/**
 * Caches an item in the respective action's cache directory.
 */
LaunchBar.cache = new CacheConf({
  configName: "cache",
  cwd: LaunchBar.action.cachePath
});

// Persist data in the respective action's "support" directory.
// LaunchBar.config = new Conf({
// 	cwd: LaunchBar.action.supportPath
// });

/**
 * perfrom HTTP requests.
 */
LaunchBar.getJSON = (url, options) => {
  options = Object.assign(
    {
      json: true
    },
    options
  );

  if (typeof url !== "string") {
    return Promise.reject(
      new TypeError(
        `Expected \`url\` to be a \`string\`, got \`${typeof url}\``
      )
    );
  }
  if (options.transform && typeof options.transform !== "function") {
    return Promise.reject(
      new TypeError(
        `Expected \`transform\` to be a \`function\`, got \`${typeof options.transform}\``
      )
    );
  }

  const rawKey = url + JSON.stringify(options);
  const key = rawKey.replace(/\./g, "\\.");

  // const cachedResponse = alfy.cache.get(key, {ignoreMaxAge: true});
  // if (cachedResponse && !alfy.cache.isExpired(key)) {
  // 	return Promise.resolve(cachedResponse);
  // }

  return got(url, options)
    .then(response =>
      options.transform ? options.transform(response.body) : response.body
    )
    .then(data => {
      // if (options.maxAge) {
      // 	alfy.cache.set(key, data, {maxAge: options.maxAge});
      // }
      return data;
    })
    .catch(error => {
      // if (cachedResponse) {
      // 	return cachedResponse;
      // }
      throw error;
    });
};

/**
 * Boilerplate function for text-processing actions.
 * @param {string} textArguments - the text to process.
 * @param {function} textProcessingFunction a function to run over each line. Should accept and return single argument -- a line of text.
 * @param {string} joiner - the separator to join back the lines into a string.
 *
 */
LaunchBar.textAction = (
  textArguments,
  textProcessingFunction,
  joiner = "\n"
) => {
  let output = [];
  // If sent arguments are strings, LB will most likely consolidate them into a single string argument
  // however, it is perfectly reasonable to send paths or other "items" to text-processing actions
  // in such cases, arguments are send as a regular array
  if (typeof textArguments === "string") {
    textArguments = [textArguments];
  }
  textArguments.forEach(textItem => {
    const linesOfTextItem = textItem.split("\n");
    linesOfTextItem.forEach(aLine => {
      output.push(textProcessingFunction(aLine));
    });
  });

  output = output.join(joiner);
  if (LaunchBar.options.commandKey) {
    return console.log(output);
  }
  return LaunchBar.paste(output);
};
